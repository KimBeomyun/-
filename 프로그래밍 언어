프로그래밍 언어의 정의
 컴퓨터와 의사 소통하기 위한 표현법(약간 부적절 한 면 존재)
 1940년대 이전 : 프로그래밍이 전선 연결(프로그래밍 언어 ?)
 1940년대 Non Nenmann 방식(Program stored computer)
  CPU가 처리할 작업을 명령 코드로 작성
  프로그래밍 개념 시작
  어셈블리 언어 탄생 : symbol 사용
    기계종속적
    저급 수준의 추상화
    읽고 쓰기 어려움
  고급 수준의 추사오하 요구 : 고급 언어 등장
    프로그램 간략, 이해 용이, 이식성 증가
    배정, 반복, 선택 개념
프로그래밍 언어의 정의는 기계가 읽을 수 있고, 사람이 읽을 수 있는 형식으로 계산을 기술하는 표현 체계이다.
프로그래밍 언어란 무엇인가?
 계산(computation)이란?
  -수학적으로 형식적인 정의 가능(Turing Machine 등)
  -컴퓨터가 처리할 수 있는 작업을 의미(일반적으론)
 기계가 읽을 수 있는(Machine - readable)
  -효과적인 번역 가능(간결한 구조의 언어 요구)
  -단순 번역 알고리즘 존재
  -제한된 시간 내에 번역 가능(프로그램 크기 단순 비례 이상적 임)
  -문맥 자유 언어(context free language) -> 위 조건들 만족
 사람이 읽을 수 있는(human-readable)
  -기계 독립적인 추상성 제공 -> 자연어 형태
  -프로그램 대형화 -> 판독성은 새로운 국면 -> 지역성 요구
  -프로그래밍 언어 -> 소프트웨어 개발 환경에 포함되는 경향
프로그래밍 언어 고찰
 -언어의 특징들에 대한 기본 개념
 -특징들의 구현과 이 때 발생하는 문제점
 -특징들의 설계에 대한 기본 개념
 -실제 언어의 도입 예 : 비교 분석
프로그래밍 언어에서의 추상화
 -추상화 개념: 주어진 작업이나 객체를 속성들의 일부분을 가지고 필요한 만큼 묘사할 수 있는 방법을 지원하는것
              필수적인 속성만으로 주어진 것을 묘사하므로 나머지 속성들은 추상화, 은닉 또는 삭제됨
 추상화 범주
  자료 추상화: 문자열, 수 ,tree 같은 계산될 자료의 특성을 추상화
  제어 추상화: 실행 순서를 제어하는 특성을 추상화 EX)반복문, 조건문, 프로시저 호출 등등
추상화에 포함된 정보의 양에 따른 분률
 기본 추상화: 가장 지역적인 기계정보에 대한 추상화
 구조 추상화: 보다 전역적인 정보인 프로그램의 구조에 대한 추상화
 단위 추상화: 단위 프록드램 전체에 대한 정보의 추상화
자료 추상화
 컴퓨터 내부의 자료 표현을 추상화
  -기억장치->변수,2진수 내부 표현의 값 -> 정수/실수 자료형
  -관련된 자료의 집합을 추사오하
  -전형적인 구조 추상화 예 : 배열, 레코드(구조형 자료)
  -구조형에 새 이름 부여 기능(새 차원의 추상화)
제어 추상화
 -몇 개의 기계 명령어를 모아 이해하기 쉬운 추상 구문으로 만드는 것
 -프로그램에서 어떤 검사된 값에 따라 분할된 명령어의 한 그룹을 수행
 -프로시저의 집합을 추상화
언어 정의의 범주
-언어에 대한 정확한 형식 기술 방법이 필요
-프로그래밍 과정에서 프로그램 동작의 이해를 위해 필요
-구문론와 의미론으로 구분
--구문론:언어 구문에 관한 정의는 형식화가 많이 되어 있음, 대부분의 언어가 문맥 자유문법을 만족하며 BNF로 정의
--의미는 프로그램 실행 시 어떤이 발생하는가를 기술
프로그래밍 언어의 정확한 형식 정의가 필요한 이유
-언어의 구조와 의미의 정확한 기술 없이는 프로그래밍이 불가능
-모호함 없는 언어 규현
-프로그래밍 과정에서 프로그램이 어떻게 동작할 것인가에 대한 문제 발생 시 유용
-프로그램 설계 과정을 규격화하는 방법
언어 설계의 기본 원칙 : 효율성, 일반성, 직교성, 획일성
기타 설계 원칙: 간결성, 안전성, 표현력, 기존 표기나 규칙과의 일관성, 정확성, 확장성, 기계 독립성, 제약성, 부분성
효율성의 기존에 따른 분류
-목적 코드의 효율성: 번역기의 효율적 실행 코드 생성 -> 최적화
-번역의 효율성: 적절한 크기의 번역기로 빠르게 번역할 수 있는 것
-구현의 효율성: 번역기의 효율적 작성 가능 여부
-프로그래밍 효율성: 프로그램 작성의 단순성, 용이성 문제, 언어의 표현성,추상화 메커니즘과 관련
-실제 효율성은 신뢰도와 관계됨
일반성: 특별한 경우를 피하거나 밀접한 관련의 여러 개념들을 하나의 개념으로 결합
일반성이 갖는 문제점: 언어의 간결성 저하, 언어의 판독성 저하 언어의 신뢰성 저하
직교성: 구선자간의 상호작용 또는 문맥의 사용이 예상 밖의 행위를 야기하지 않아야 함
비직교성: 문맥에 의존하는 제한    비일반성: 문맥과 관계없는 제한
획일성: 유사한 것들은 유사하게 보이고 유사한 의미를 갖게 하며, 상이한 것들은 서로 다르게 보이고 서로 다르게 행동하여야 된다는 성질
-비획일성은 특별한 문맥에서만 발생되고 구성자들 간의 상호작용으로 볼 수 있으므로 비직교성으로 간주될 수도 있다.
간결성
-Pascal의 주된 설계 원칙은 간결성, 직교성, 일반성, 획일성 : 간결성 보장 못함
-구성자의 수가 적다고 언어가 간결한 것은 아님, 과다한 단순성 - 언어 사용에 방해, 표현력이 부족, 많은 제한 발생
표현력 : 복잡한 과정이나 구조를 표현하는데 용이함을 의미, 표현력은 강하나 단순하지 않은 언어, 표현력이 강하면서 단순한 언어
정확성 = 명확성: 언어에 대한 정확한 정의 -> 언어의 행위가 예측 가능한 정의의 존재 여부, 정확한 언어 정의 -> 언어의 신뢰도, 번역기의 신뢰고듸 영향
기계 독립성: 기계 독립적인 언어 정의를 통하여 보장(호환성 제공), 기억 장소 할당과 기계 구조와 별개로 정의된 자료형 사용
안전성: 프로그래밍 오류를 줄이고, 오류 발견 용이한 언어 목표, 언어의 신뢰성과 정확성에 밀접한 관계, 언어 설계시 자료형, 형 검사, 변수선언을 도입
기존 표기나 규칙과의 일관성: 언어 설계 시 표준화된 특성과 개념을 갖도록 해야 함
확장성
-사용자가 언어의 특성을 쉽게 부가하도록 허용하는 기법
-확장성을 가진 언어의 예
-명령형 언어는 함수형 언어보다 언어 확장이 어려움
-추상화 개념(자료 추상화, 제어 추상화)는 확장성 지원
제약성, 부분성
-일부의 언어 지식과 언어 구조만 가지고도 효과적인 프로그램 작성 가능
-언어 제한성의 장점: 프로그래머는 언어의 효과적인 사용을 위해 언어 전체를 배울 필요 없음
언어 구문 - 프로그래밍 언어의 기본 문자 집합
정합 순서
-문자 또는 문자열에 대한 일반적인 순서언어 : EX) 0<1<2...., A<B<C....
-언어 구현 시에 결정, 일반적으로 문자의 bit 조합 표현 순서에 영향(코드 체계 따름)
어위 구조 용어
어휘 토큰, 어휘 요소, 어휘 단위: 기본 의미 단위를 표현하는 한 개이상의 프로그래밍 언어의 알파벳 문자로 구성된 문자열
언어 구성자 : 한 개 이상의 어휘 토큰으로 형성되며, 구문적으로 허용된 프로그램의 일부
식별자, 미리 정의 된 식별자, 예약어
-언어 어휘를 구성하는 단어나 기호 형태의 문자 알파벳, 변수 이름으로 사용할 수 없음
-장점 : 프로그램 판독성 증가, 컴파일러가 기호 테이블을 빠른 시간에 탐색
-많은 예약어 -> 언어 확장시 신 예약어와 이전에 사용된 프로그램의 식별자와 중복 우려
BNF 표기법
-구문형식을 정의하는 가장 보편적인 표기법
-한 언어 구문에 대한 BNF정의: 언어의 문장을 생성하는 생성 규칙 정의
-생성 규칙 : 생성 규칙의 왼쪽(정의될 대상) , 오른쪽에는 그 대상에 대한 정의를 표현
-BNF 표기법에 의한 식별자 정의 예
EBNF 표기법
-BNF 표기법을 확장하여 보다 읽기 쉽고, 간단하게 표현된 표기법
-BNF보다 추가된 특수한 의미를 갖는 EBNF의 메타 기호 
구문도표
-구문 도표는 그 형태가 순서도와 유사
-구문 도표는 EBNF와 일대일 대응 : 다시 정의될 대상은 box로, 터미널 기호는 원이나 타원형으로 표시, 이들 사이는 지시선으로 연결
파스트리
-원시 프로그램의 문법 검사 과정에서 내부적으로 생성되는 트리 형태의 자료구조
-문장 표현이 BNF에 의해 작성될 수 있는지 여부를 나타냄
구문: 언어의 신뢰성에 영향
프로그래밍 언어 구현 기법
-고급 언어는 기계어나 그와 상응하는 언어로 번역되어야만 함
번역기법의 종류
컴파일러 
-원시언어 : 고급언어 / 목적 언어 : 실제 기계 언어에 가까운 저급 언어
-저급 언어 : 준 기계어 형태 또는 어셈블리 언어
어셈블러
-원시 언어 : 어셈블리 언어 / 목적 언어 : 준 기계어 형태
링케이지 에디터
-여러 개의 프로그램(재배치 형태 기계어)를 묶음 -> 로드 모듈 생성
-로드 모듈 : 어느 정도 실행 가능한 하나의 기계어 프로그램
로더
-기계어 프로그램(로드 모듈)을 실제 실행 가능한 기계어로 번역해서 주 기억장치에 적재
프리프로세서
-원시 언어와 목적 언어가 모두 고급 언어인 번역기
-고급 언어에 대한 언어를 확장하여 구현할 때 유용
인터프리터 기법
-고급 언어 기계를 다른 기계에서 소프트웨어로 simulation하는 방법
번역기: 입력 프로그램과 동일한 의미의 목적 언어 프로그램 생성
인터프리터 : 직접 입력 프로그램을 실행하는 방법으로 처리
비교분석
-순수 번역 기법(Assembly 등 저급 언어 가능)
-순수 시뮬레이션 기법(JCL, APL 등)
-번역 효율적인 부분(반복 수행부와 수식 계산 등)존재
-원시 코드의 simulation이 효율적인 부분(I/O routine등)존재
-순수 번역 기법이나 순수 시뮬레이션 기법은 실제로 거의 존재치 않음
번억 기법의 장단점
-장점 : 실해 시간 효율성 제공(한번 decoding으로 반복 실행)
-단점 : 번역된 프로그램이 큰 기억 장치 요구
인터프리터 기법의 장단점
-번역기법과 장단점이 반대
-사용자 적응성 제공
하이브리드 기법
-프로그램을 실행시키기 쉬운 형태로 번역한 후, 번역된 프로그램을 시뮬레이션으로 실행
-현재 대부분의 인터프리터 언어가 이 방법을 따름
-중간 형태 코드가 저급언어이면 번역 기법으로 간주되기도 함
컴파일러 언어
장점: 기계어로 번역된 것을 하드웨어 인터프리터가 decoding하여 실행
인터프리터 언어
구현방법 : 번역기가 중간언어를 생성 후, 이를 다시 소프트웨어 인터프리터로 실행(하이브리드 방법)\
장점: 컴파일러 방법보다 실행 시간이 비효율적이지만 사용자에게 적을성을 


